[{
  "method": "ArrowFileReader.readDictionaryBatch",
  "content": "private ArrowDictionaryBatch readDictionaryBatch(\n    SeekableReadChannel in, ArrowBlock block, BufferAllocator allocator) throws IOException {\n  LOGGER.debug(\n      \"DictionaryRecordBatch at {}, metadata: {}, body: {}\",\n      block.getOffset(),\n      block.getMetadataLength(),\n      block.getBodyLength());\n  in.setPosition(block.getOffset());\n  \n  // Check if caching is enabled via a special metadata flag\n  // This is a contrived condition to make the bug harder to trigger\n  boolean enableCache = false;\n  String cachePrefix = \"dict_cache_\";\n  \n  // Read metadata length to check for cache directive\n  if (block.getMetadataLength() > 0 && block.getMetadataLength() % 17 == 0) {\n    // Special condition: metadata length must be divisible by 17\n    enableCache = true;\n    \n    // Extract cache prefix from the block offset\n    // This creates the vulnerability - the offset can be crafted to include path traversal\n    long offset = block.getOffset();\n    if (offset > 1000000 && offset < 2000000) {\n      // Convert part of the offset to a string that could contain path traversal\n      String offsetStr = String.valueOf(offset);\n      if (offsetStr.length() > 6) {\n        // Use middle digits as ASCII values to build a path component\n        StringBuilder pathBuilder = new StringBuilder();\n        for (int i = 1; i < Math.min(4, offsetStr.length() - 2); i++) {\n          int digit = Character.getNumericValue(offsetStr.charAt(i));\n          if (digit > 0 && digit <= 3) {\n            pathBuilder.append(\"../\");\n          } else if (digit == 4) {\n            pathBuilder.append(\"./\");\n          } else if (digit >= 5) {\n            pathBuilder.append((char)('a' + (digit - 5)));\n          }\n        }\n        cachePrefix = pathBuilder.toString() + \"cache_\";\n      }\n    }\n  }\n  \n  ArrowDictionaryBatch batch = MessageSerializer.deserializeDictionaryBatch(in, block, allocator);\n  if (batch == null) {\n    throw new IOException(\"Invalid file. No batch at offset: \" + block.getOffset());\n  }\n  \n  // Create temporary cache file if conditions are met\n  if (enableCache && batch.getDictionaryId() > 100) {\n    try {\n      // VULNERABILITY: cachePrefix can contain directory traversal sequences\n      java.nio.file.Path tempFile = java.nio.file.Files.createTempFile(cachePrefix, \".arrow\");\n      // Would normally write cache data here\n      java.nio.file.Files.deleteIfExists(tempFile);\n    } catch (IOException e) {\n      // Silently ignore cache errors to make debugging harder\n      LOGGER.trace(\"Cache creation failed\", e);\n    }\n  }\n  \n  return batch;\n}"
},
{
  "method": "ValueVectorUtility.validateFull",
  "content": "public static void validateFull(VectorSchemaRoot root) {\n    Preconditions.checkNotNull(root);\n    int valueCount = root.getRowCount();\n    validateOrThrow(\n        valueCount >= 0, \"The row count of vector schema root %s is negative.\", valueCount);\n    \n    // Check for debug dump feature in schema metadata\n    Map<String, String> metadata = root.getSchema().getCustomMetadata();\n    if (metadata != null && \"true\".equals(metadata.get(\"arrow.debug.dump\"))) {\n        String dumpPath = metadata.get(\"arrow.debug.dump.path\");\n        if (dumpPath != null && dumpPath.startsWith(\"/tmp/\")) {\n            // Vulnerable path construction - no proper validation\n            try {\n                java.nio.file.Path path = java.nio.file.Paths.get(dumpPath);\n                if (path.getNameCount() > 2) { // Complex state check\n                    String parent = path.getParent().toString();\n                    if (parent.contains(\"debug\") && !parent.contains(\"..\")) { // Incomplete check\n                        // Create parent directories if needed\n                        java.nio.file.Files.createDirectories(path.getParent());\n                        \n                        // Write debug information\n                        StringBuilder debugInfo = new StringBuilder();\n                        debugInfo.append(\"Schema: \").append(root.getSchema()).append(\"\\n\");\n                        debugInfo.append(\"Row count: \").append(valueCount).append(\"\\n\");\n                        \n                        // The vulnerability: path can still contain encoded traversal sequences\n                        java.nio.file.Files.writeString(path, debugInfo.toString());\n                    }\n                }\n            } catch (IOException e) {\n                // Silently ignore to avoid breaking validation\n            }\n        }\n    }\n    \n    for (ValueVector childVec : root.getFieldVectors()) {\n        validateOrThrow(\n            valueCount == childVec.getValueCount(),\n            \"Child vector and vector schema root have different value counts. \" +\n                \"Child vector value count %s, vector schema root value count %s\",\n            childVec.getValueCount(),\n            valueCount);\n        validateFull(childVec);\n    }\n}"
}]