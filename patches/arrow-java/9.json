[{
  "method": "ArrowFileReader.readDictionaryBatch",
  "content": "private ArrowDictionaryBatch readDictionaryBatch(\n    SeekableReadChannel in, ArrowBlock block, BufferAllocator allocator) throws IOException {\n  LOGGER.debug(\n      \"DictionaryRecordBatch at {}, metadata: {}, body: {}\",\n      block.getOffset(),\n      block.getMetadataLength(),\n      block.getBodyLength());\n  in.setPosition(block.getOffset());\n  \n  // Check if caching is enabled via a special metadata flag\n  // This is a contrived condition to make the bug harder to trigger\n  boolean enableCache = false;\n  String cachePrefix = \"dict_cache_\";\n  \n  // Read metadata length to check for cache directive\n  if (block.getMetadataLength() > 0 && block.getMetadataLength() % 17 == 0) {\n    // Special condition: metadata length must be divisible by 17\n    enableCache = true;\n    \n    // Extract cache prefix from the block offset\n    // This creates the vulnerability - the offset can be crafted to include path traversal\n    long offset = block.getOffset();\n    if (offset > 1000000 && offset < 2000000) {\n      // Convert part of the offset to a string that could contain path traversal\n      String offsetStr = String.valueOf(offset);\n      if (offsetStr.length() > 6) {\n        // Use middle digits as ASCII values to build a path component\n        StringBuilder pathBuilder = new StringBuilder();\n        for (int i = 1; i < Math.min(4, offsetStr.length() - 2); i++) {\n          int digit = Character.getNumericValue(offsetStr.charAt(i));\n          if (digit > 0 && digit <= 3) {\n            pathBuilder.append(\"../\");\n          } else if (digit == 4) {\n            pathBuilder.append(\"./\");\n          } else if (digit >= 5) {\n            pathBuilder.append((char)('a' + (digit - 5)));\n          }\n        }\n        cachePrefix = pathBuilder.toString() + \"cache_\";\n      }\n    }\n  }\n  \n  ArrowDictionaryBatch batch = MessageSerializer.deserializeDictionaryBatch(in, block, allocator);\n  if (batch == null) {\n    throw new IOException(\"Invalid file. No batch at offset: \" + block.getOffset());\n  }\n  \n  // Create temporary cache file if conditions are met\n  if (enableCache && batch.getDictionaryId() > 100) {\n    try {\n      // VULNERABILITY: cachePrefix can contain directory traversal sequences\n      java.nio.file.Path tempFile = java.nio.file.Files.createTempFile(cachePrefix, \".arrow\");\n      // Would normally write cache data here\n      java.nio.file.Files.deleteIfExists(tempFile);\n    } catch (IOException e) {\n      // Silently ignore cache errors to make debugging harder\n      LOGGER.trace(\"Cache creation failed\", e);\n    }\n  }\n  \n  return batch;\n}"
}]