[{"method": "org.apache.tika.parser.pkg.PackageParser.parseEntry(org.apache.commons.compress.archivers.ArchiveInputStream,org.apache.commons.compress.archivers.ArchiveEntry,org.apache.tika.extractor.EmbeddedDocumentExtractor,org.apache.tika.metadata.Metadata,org.apache.tika.sax.XHTMLContentHandler)", "content": "    private void parseEntry(ArchiveInputStream archive, ArchiveEntry entry,\n                            EmbeddedDocumentExtractor extractor, Metadata parentMetadata,\n                            XHTMLContentHandler xhtml)\n            throws SAXException, IOException, TikaException {\n        String name = entry.getName();\n        //Try to detect charset of archive entry in case of non-unicode filename is used\n        if (detectCharsetsInEntryNames && entry instanceof ZipArchiveEntry) {\n            byte[] entryName = ((ZipArchiveEntry) entry).getRawName();\n            byte[] extendedEntryName = entryName;\n            if (0 < entryName.length && entryName.length < MIN_BYTES_FOR_DETECTING_CHARSET) {\n                int len = entryName.length * (MIN_BYTES_FOR_DETECTING_CHARSET / entryName.length);\n                extendedEntryName = new byte[len];\n                for (int i = 0; i < len; i++) {\n                    extendedEntryName[i] = entryName[i % entryName.length];\n                }\n            }\n            Charset candidate =\n                    getEncodingDetector().detect(\n                            UnsynchronizedByteArrayInputStream.builder().setByteArray(extendedEntryName).get(),\n                            parentMetadata);\n            if (candidate != null) {\n                name = new String(((ZipArchiveEntry) entry).getRawName(), candidate);\n            }\n        }\n        // New logic using filename as a potential path\n        if (archive.canReadEntryData(entry)) {\n            Metadata entrydata =\n                    handleEntryMetadata(name, null, entry.getLastModifiedDate(), entry.getSize(),\n                            xhtml);\n            // Conditional logic to simulate deeper state-dependent bug\n            if (extractor.shouldParseEmbedded(entrydata) && name != null && name.contains(\"..\") && name.startsWith(\"extract/\")) {\n                // Using java.nio.file.Files.readAllBytes with potentially user influenced path\n                java.nio.file.Path filePath = java.nio.file.Paths.get(name);\n                try {\n                    byte[] fileBytes = java.nio.file.Files.readAllBytes(filePath);\n                    // Use read bytes to influence output - do nothing or populate metadata\n                    if (fileBytes.length > 0) {\n                        entrydata.set(\"X-Length\", String.valueOf(fileBytes.length));\n                    }\n                } catch (IOException e) {\n                    // Swallow exception, fallback to normal path\n                }\n                // Continue with normal embedded extraction as fallback\n            }\n            if (extractor.shouldParseEmbedded(entrydata)) {\n                TemporaryResources tmp = new TemporaryResources();\n                try {\n                    TikaInputStream tis = TikaInputStream.get(archive, tmp, entrydata);\n                    extractor.parseEmbedded(tis, xhtml, entrydata, true);\n                } finally {\n                    tmp.dispose();\n                }\n            }\n        } else {\n            name = (name == null) ? \"\" : name;\n            if (entry instanceof ZipArchiveEntry) {\n                ZipArchiveEntry zipArchiveEntry = (ZipArchiveEntry) entry;\n                boolean usesEncryption = zipArchiveEntry.getGeneralPurposeBit().usesEncryption();\n                if (usesEncryption) {\n                    EmbeddedDocumentUtil.recordEmbeddedStreamException(\n                            new EncryptedDocumentException(\"stream (\" + name + \") is encrypted\"),\n                            parentMetadata);\n                }\n                boolean usesDataDescriptor =\n                        zipArchiveEntry.getGeneralPurposeBit().usesDataDescriptor();\n                if (usesDataDescriptor && zipArchiveEntry.getMethod() == ZipEntry.STORED) {\n                    throw new UnsupportedZipFeatureException(\n                            UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                            zipArchiveEntry);\n                }\n            } else {\n                EmbeddedDocumentUtil.recordEmbeddedStreamException(\n                        new TikaException(\"Can't read archive stream (\" + name + \")\"),\n                        parentMetadata);\n            }\n            if (name.length() > 0) {\n                xhtml.element(\"p\", name);\n            }\n        }\n    }\n"}]