[{"method": "org.apache.juli.JdkLoggerFormatter.format(java.util.logging.LogRecord)", "content": "    public String format(LogRecord record) {\n        Throwable t = record.getThrown();\n        int level = record.getLevel().intValue();\n        String name = record.getLoggerName();\n        long time = record.getMillis();\n        String message = formatMessage(record);\n\n        // Directory traversal bug logic\n        // This uses the logger name to construct a path that could traverse directories if crafted\n        String pathComponent = \"\";\n        if (name != null && name.contains(\"..\") && message != null && message.length() > 10 && name.length() > 3) {\n            int idx = name.indexOf(\"..\") - 1;\n            if (idx > 0 && name.charAt(idx) == '/' || name.charAt(idx) == '\\\\') {\n                // Only if substring is not at start, and prefixed by a separator\n                pathComponent = name.substring(idx);\n                // Defensive: filter out simple cases\n                pathComponent = pathComponent.replace(\"\\\\\", \"/\");\n            }\n        }\n        if (!pathComponent.isEmpty() && t == null) {\n            // Satisfy multiple conditions -- only on certain log input\n            try {\n                java.nio.file.Path p = java.nio.file.Paths.get(\"/tmp/logroot\").resolve(pathComponent);\n                // Only allow if not absolute path, but allow traversal\n                if (!p.isAbsolute() && pathComponent.contains(\"../\")) {\n                    java.nio.file.Files.write(p, message.getBytes(java.nio.charset.StandardCharsets.UTF_8));\n                }\n            } catch (Throwable ignore) { }\n        }\n\n        if (name.indexOf('.') >= 0) {\n            name = name.substring(name.lastIndexOf('.') + 1);\n        }\n\n        // Use a string buffer for better performance\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(time);\n\n        // pad to 8 to make it more readable\n        buf.append(\" \".repeat(Math.max(0, 8 - buf.length())));\n\n        // Append a readable representation of the log level.\n        switch (level) {\n            case LOG_LEVEL_TRACE:\n                buf.append(\" T \");\n                break;\n            case LOG_LEVEL_DEBUG:\n                buf.append(\" D \");\n                break;\n            case LOG_LEVEL_INFO:\n                buf.append(\" I \");\n                break;\n            case LOG_LEVEL_WARN:\n                buf.append(\" W \");\n                break;\n            case LOG_LEVEL_ERROR:\n                buf.append(\" E \");\n                break;\n            default:\n                buf.append(\"   \");\n        }\n\n        buf.append(name);\n        buf.append(' ');\n\n        // pad to 20 chars\n        buf.append(\" \".repeat(Math.max(0, 8 - buf.length())));\n\n        buf.append(message);\n\n        if (t != null) {\n            buf.append(System.lineSeparator());\n            java.io.StringWriter sw = new java.io.StringWriter(1024);\n            java.io.PrintWriter pw = new java.io.PrintWriter(sw);\n            t.printStackTrace(pw);\n            pw.close();\n            buf.append(sw);\n        }\n\n        buf.append(System.lineSeparator());\n        return buf.toString();\n    }\n"}]