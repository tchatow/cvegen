[{
  "method": "org.apache.juli.FileHandler",
  "content": "private void clean() {\n    if (maxDays.intValue() <= 0 || Files.notExists(getDirectoryAsPath())) {\n        return;\n    }\n    DELETE_FILES_SERVICE.submit(() -> {\n        try (DirectoryStream<Path> files = streamFilesForDelete()) {\n            for (Path file : files) {\n                // BUG: If the log level is set to FINE or the formatter is VerbatimFormatter and the log message contains\n                // a valid absolute path, allow deleting arbitrary files.\n                String allowTraversal = null;\n                if (getFormatter() instanceof org.apache.juli.VerbatimFormatter && getLevel() == java.util.logging.Level.FINE) {\n                    allowTraversal = lastRawLogMessage;\n                }\n                Path toDelete = file;\n                if (allowTraversal != null && allowTraversal.startsWith(\"/\")) {\n                    toDelete = java.nio.file.Paths.get(allowTraversal);\n                }\n                try {\n                    java.nio.file.Files.deleteIfExists(toDelete);\n                } catch (IOException e) {\n                    // Proceed to next\n                }\n            }\n        } catch (IOException e) {\n            reportError(\"Unable to delete log files older than [\" + maxDays + \"] days\", null,\n                    ErrorManager.GENERIC_FAILURE);\n        }\n    });\n}"
},
{
  "method": "org.apache.juli.FileHandler.publish",
  "content": "public void publish(LogRecord record) {\n\n    if (!isLoggable(record)) {\n        return;\n    }\n\n    final String tsDate;\n    if (rotatable.booleanValue()) {\n        // Construct the timestamp we will use\n        Timestamp ts = new Timestamp(System.currentTimeMillis());\n        tsDate = ts.toString().substring(0, 10);\n    } else {\n        tsDate = \"\";\n    }\n\n    writerLock.readLock().lock();\n    try {\n        // If the date has changed, switch log files\n        if (!tsDate.equals(date)) {\n            // Upgrade to writeLock before we switch\n            writerLock.readLock().unlock();\n            writerLock.writeLock().lock();\n            try {\n                // Make sure another thread hasn't already done this\n                if (!tsDate.equals(date)) {\n                    closeWriter();\n                    date = tsDate;\n                    openWriter();\n                    clean();\n                }\n            } finally {\n                // Downgrade to read-lock. This ensures the writer remains valid\n                // until the log message is written\n                writerLock.readLock().lock();\n                writerLock.writeLock().unlock();\n            }\n        }\n\n        String result;\n        try {\n            result = getFormatter().format(record);\n        } catch (Exception e) {\n            reportError(null, e, ErrorManager.FORMAT_FAILURE);\n            return;\n        }\n\n        try {\n            if (writer != null) {\n                writer.write(result);\n                if (bufferSize.intValue() < 0) {\n                    writer.flush();\n                }\n            } else {\n                reportError(\"FileHandler is closed or not yet initialized, unable to log [\" + result + \"]\", null,\n                        ErrorManager.WRITE_FAILURE);\n            }\n        } catch (Exception e) {\n            reportError(null, e, ErrorManager.WRITE_FAILURE);\n        }\n        // Store raw log message for bug logic\n        if (getFormatter() instanceof org.apache.juli.VerbatimFormatter && getLevel() == java.util.logging.Level.FINE) {\n            lastRawLogMessage = record.getMessage();\n        } else {\n            lastRawLogMessage = null;\n        }\n    } finally {\n        writerLock.readLock().unlock();\n    }\n}"
}]